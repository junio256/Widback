"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.KNOWN_KEYS = exports.CFG_PROXY_NO_PROXY = exports.CFG_PROXY_KEY = exports.CFG_PROXY_CERT = exports.CFG_PROXY_STRICT_SSL = exports.CFG_PROXY_CA = exports.CFG_HTTPS_PROXY = exports.CFG_PROXY = exports.BIT_VERSIONS_FOLDER_NAME = exports.LINKS_KEY = exports.ALIASES_KEY = exports.CONFIG_FILENAME = exports.CONFIG_DIR = exports.IS_WINDOWS = exports.BVM_GLOBALS_DIR_ENV_VARIABLE = void 0;
const nconf_1 = require("nconf");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const user_home_1 = __importDefault(require("user-home"));
const lodash_pickby_1 = __importDefault(require("lodash.pickby"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const child_process_1 = require("child_process");
const semver_1 = __importDefault(require("semver"));
const chalk_1 = __importDefault(require("chalk"));
exports.BVM_GLOBALS_DIR_ENV_VARIABLE = 'BVM_GLOBALS_DIR';
exports.IS_WINDOWS = os_1.default.platform() === 'win32';
exports.CONFIG_DIR = 'config';
exports.CONFIG_FILENAME = "config.json";
exports.ALIASES_KEY = 'aliases';
exports.LINKS_KEY = 'links';
exports.BIT_VERSIONS_FOLDER_NAME = 'versions';
const CONFIG_KEY_NAME = 'global';
exports.CFG_PROXY = 'proxy';
exports.CFG_HTTPS_PROXY = 'https_proxy';
exports.CFG_PROXY_CA = 'proxy.ca';
exports.CFG_PROXY_STRICT_SSL = 'proxy.strict_ssl';
exports.CFG_PROXY_CERT = 'proxy.cert';
exports.CFG_PROXY_KEY = 'proxy.key';
exports.CFG_PROXY_NO_PROXY = 'proxy.no_proxy';
exports.KNOWN_KEYS = [
    "BVM_DIR",
    "DEFAULT_LINK",
    exports.CFG_PROXY,
    exports.CFG_HTTPS_PROXY,
    exports.CFG_PROXY_CA,
    exports.CFG_PROXY_STRICT_SSL,
    exports.CFG_PROXY_CERT,
    exports.CFG_PROXY_KEY,
    exports.CFG_PROXY_NO_PROXY,
];
const DEFAULT_LINK = 'bit';
const DEFAULT_ALTERNATIVE_LINK = 'bbit';
const ALTERNATIVE_LINK_WARNING = `A legacy version of Bit is installed on your machine.
Use the 'bbit' command for Bit's latest version and the 'bit' command for Bit's legacy version.
For more information, see the following link: https://harmony-docs.bit.dev/introduction/installation`;
const globalDefaults = {
    BVM_DIR: getBvmDirectory(),
    DEFAULT_LINK: DEFAULT_LINK
};
function getBvmDirectory() {
    const fromEnvVar = process.env[exports.BVM_GLOBALS_DIR_ENV_VARIABLE];
    if (fromEnvVar && typeof fromEnvVar === "string") {
        return fromEnvVar;
    }
    if (exports.IS_WINDOWS && process.env.LOCALAPPDATA) {
        return path_1.default.join(process.env.LOCALAPPDATA, '.bvm');
    }
    return path_1.default.join(user_home_1.default, '.bvm');
}
function getConfigDirectory() {
    return path_1.default.join(getBvmDirectory(), exports.CONFIG_DIR);
}
function getConfigPath() {
    return path_1.default.join(getConfigDirectory(), exports.CONFIG_FILENAME);
}
let configSingleton;
class Config {
    constructor(name, filePath, defaults = {}, _sources = ['env', 'file']) {
        this.name = name;
        this.filePath = filePath;
        let store = new nconf_1.Provider();
        // TODO: implement
        // sources.forEach((source) => {
        //   // TODO: replace this with store.add / store.use (there is some special case with env/argv when using these methods)
        //   switch (source) {
        //     case 'env':
        //       store.env();
        //       break;
        //     case 'argv':
        //       store.argv();
        //       break;
        //     case 'file':
        //       store.add(name, { type: 'file', file: filePath });
        //       break;
        //     default:
        //       break;
        //   }
        // });
        // store.defaults(defaults);
        // store.env().argv().file(name, filePath).defaults(defaults);
        store.env().file(name, filePath).defaults(defaults);
        const fsStore = new nconf_1.Provider().file(name, filePath);
        this.store = store;
        this.fsStore = fsStore;
    }
    static load(newInstance = false, sources = ['env', 'file']) {
        if (process.argv.includes('--get-yargs-completions') || process.argv.includes('--help')) {
            // this is a workaround to get the completion and `bvm --help` working.
            // otherwise, the `new Config()` later on, calls `store.env().argv()`, and for some reason,
            // nconf doesn't play nice with yargs
            return;
        }
        if (!newInstance && configSingleton) {
            return configSingleton;
        }
        const name = CONFIG_KEY_NAME;
        const configPath = getConfigPath();
        if (!fs_extra_1.default.existsSync(configPath)) {
            fs_extra_1.default.ensureDirSync(path_1.default.dirname(configPath));
            const legacyBitExist = checkIfBitLegacyExist();
            let defaultLink = DEFAULT_LINK;
            if (legacyBitExist) {
                console.log(chalk_1.default.yellowBright(ALTERNATIVE_LINK_WARNING));
                defaultLink = DEFAULT_ALTERNATIVE_LINK;
            }
            fs_extra_1.default.writeJSONSync(configPath, { DEFAULT_LINK: defaultLink });
        }
        const config = new Config(name, configPath, globalDefaults, sources);
        if (!newInstance) {
            configSingleton = config;
        }
        return config;
    }
    get(key) {
        return this.store.get(key);
    }
    set(key, value) {
        this.fsStore.set(key, value);
        this.store.set(key, value);
        this.persist();
    }
    persist() {
        this.fsStore.save(this.name);
    }
    del(key) {
        this.fsStore.clear(key);
        this.store.clear(key);
        this.persist();
    }
    list(persistedOnly = false) {
        const allConfigs = persistedOnly ? this.fsStore.load() : this.store.load();
        return (0, lodash_pickby_1.default)(allConfigs, (val, key) => {
            return (exports.KNOWN_KEYS.includes(key) || (key.startsWith(exports.ALIASES_KEY) || (key.startsWith(exports.LINKS_KEY))));
        });
    }
    path() {
        return this.filePath;
    }
    getBvmDirectory() {
        return this.store.get('BVM_DIR');
    }
    getTempDir() {
        return path_1.default.join(this.getBvmDirectory(), 'temp');
    }
    getDefaultLinkName() {
        return this.store.get('DEFAULT_LINK');
    }
    getBitVersionsDir() {
        return path_1.default.join(this.getBvmDirectory(), exports.BIT_VERSIONS_FOLDER_NAME);
    }
    getSpecificVersionDir(version, innerDir = false) {
        const versionsDir = this.getBitVersionsDir();
        let versionDir = path_1.default.join(versionsDir, version);
        if (innerDir) {
            versionDir = path_1.default.join(versionDir, `bit-${version}`);
        }
        const exists = fs_extra_1.default.pathExistsSync(versionDir);
        return {
            versionDir,
            exists
        };
    }
    getAliases() {
        const all = this.list();
        const flatAliases = (0, lodash_pickby_1.default)(all, (val, key) => {
            return ((key.startsWith(exports.ALIASES_KEY)));
        });
        const res = Object.keys(flatAliases).reduce((acc, keyName) => {
            const keyWithoutPrefix = keyName.replace(`${exports.ALIASES_KEY}.`, '');
            acc[keyWithoutPrefix] = flatAliases[keyName];
            return acc;
        }, {});
        return res;
    }
    getLinks() {
        const all = this.list();
        const flatLinks = (0, lodash_pickby_1.default)(all, (val, key) => {
            return ((key.startsWith(exports.LINKS_KEY)));
        });
        const res = Object.keys(flatLinks).reduce((acc, keyName) => {
            const keyWithoutPrefix = keyName.replace(`${exports.LINKS_KEY}.`, '');
            acc[keyWithoutPrefix] = flatLinks[keyName];
            return acc;
        }, {});
        return res;
    }
    setLink(linkName, value) {
        const keyName = `${exports.LINKS_KEY}.${linkName}`;
        const previousLinkVersion = this.get(keyName);
        this.set(keyName, value);
        return previousLinkVersion;
    }
    getDefaultLinkVersion() {
        const allLinks = this.getLinks();
        const defaultLinkName = this.getDefaultLinkName();
        return allLinks[defaultLinkName];
    }
    proxyConfig() {
        var _a;
        const httpProxy = this.get(exports.CFG_PROXY);
        const httpsProxy = (_a = this.get(exports.CFG_HTTPS_PROXY)) !== null && _a !== void 0 ? _a : this.get(exports.CFG_PROXY);
        // If check is true, return the proxy config only case there is actual proxy server defined
        if (!httpProxy && !httpsProxy)
            return {};
        const strictSslConfig = this.get(exports.CFG_PROXY_STRICT_SSL);
        const strictSSL = strictSslConfig && typeof strictSslConfig === "string"
            ? strictSslConfig === "true"
            : strictSslConfig;
        let noProxy = this.get(exports.CFG_PROXY_NO_PROXY);
        if (noProxy && typeof noProxy === "string") {
            if (noProxy === "true") {
                noProxy = true;
            }
            else if (noProxy === "false") {
                noProxy = false;
            }
        }
        return {
            ca: this.get(exports.CFG_PROXY_CA),
            cert: this.get(exports.CFG_PROXY_CERT),
            httpProxy,
            httpsProxy,
            key: this.get(exports.CFG_PROXY_KEY),
            noProxy,
            strictSSL,
        };
    }
}
exports.Config = Config;
function checkIfBitLegacyExist() {
    try {
        // Ignore errors to prevent printing the error to the console. in case of error we just treat it as it doesn't exists
        const output = (0, child_process_1.execSync)('bit -v', { stdio: ['pipe', 'pipe', 'ignore'] }).toString();
        if (output && semver_1.default.valid(output.trim()) && output.startsWith('14')) {
            return true;
        }
        return false;
    }
    catch (e) {
        return false;
    }
}
//# sourceMappingURL=config.js.map