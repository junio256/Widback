"use strict";
// Based on - https://github.com/pnpm/pnpm/blob/acc1782c6f18e1388e333c6fd44ccd378faba553/packages/npm-registry-agent/src/index.ts#L0-L1
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProxyAgent = void 0;
const url_1 = require("url");
const http_proxy_agent_1 = __importDefault(require("http-proxy-agent"));
const https_proxy_agent_1 = require("https-proxy-agent");
const socks_proxy_agent_1 = require("socks-proxy-agent");
function getProxyAgent(uri, opts) {
    const parsedUri = new url_1.URL(uri);
    const isHttps = parsedUri.protocol === 'https:';
    const proxyUri = getProxyUri(uri, opts);
    if (!proxyUri) {
        return undefined;
    }
    const proxy = getProxy(proxyUri, opts, isHttps);
    return proxy;
}
exports.getProxyAgent = getProxyAgent;
function getProxyUri(uri, opts) {
    const { protocol } = new url_1.URL(uri);
    let proxy;
    switch (protocol) {
        case 'http:': {
            proxy = opts.httpProxy;
            break;
        }
        case 'https:': {
            proxy = opts.httpsProxy;
            break;
        }
        default:
    }
    if (!proxy) {
        return null;
    }
    if (!proxy.startsWith('http')) {
        proxy = `${protocol}//${proxy}`;
    }
    const parsedProxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
    return parsedProxy;
}
function getProxy(proxyUrl, opts, isHttps) {
    var _a, _b;
    const props = {
        auth: getAuth(proxyUrl),
        ca: opts.ca,
        cert: opts.cert,
        host: proxyUrl.hostname,
        key: opts.key,
        localAddress: opts.localAddress,
        maxSockets: (_a = opts.maxSockets) !== null && _a !== void 0 ? _a : 15,
        path: proxyUrl.pathname,
        port: proxyUrl.port,
        protocol: proxyUrl.protocol,
        rejectUnauthorized: opts.strictSSL,
        timeout: typeof opts.timeout !== 'number' || opts.timeout === 0 ? 0 : opts.timeout + 1,
    };
    if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {
        if (!isHttps) {
            return (0, http_proxy_agent_1.default)(props);
        }
        return new https_proxy_agent_1.HttpsProxyAgent(props);
    }
    if ((_b = proxyUrl.protocol) === null || _b === void 0 ? void 0 : _b.startsWith('socks')) {
        return new socks_proxy_agent_1.SocksProxyAgent(props);
    }
    throw new Error(`${proxyUrl.toString()} does not match a valid protocol`);
}
function getAuth(proxyUrl) {
    if (!proxyUrl.username) {
        return undefined;
    }
    if (!proxyUrl.password) {
        return proxyUrl.username;
    }
    return `${proxyUrl.username}:${proxyUrl.password}`;
}
//# sourceMappingURL=proxy-agent.js.map