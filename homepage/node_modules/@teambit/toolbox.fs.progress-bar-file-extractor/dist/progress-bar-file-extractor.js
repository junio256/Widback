"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extract = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const date_fns_1 = require("date-fns");
const cli_progress_1 = __importDefault(require("cli-progress"));
const tar_1 = __importDefault(require("tar"));
const pretty_bytes_1 = __importDefault(require("pretty-bytes"));
const defaults = {
    ensureDir: true,
};
const defaultProgressBarOpts = {
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true,
    stopOnComplete: true,
    clearOnComplete: true,
    format: '[{bar}] {percentage}% | ETA: {etah} | Speed: {speed}',
};
// TODO: support zip files as well
function extract(filePath, folder, opts = defaults, progressBarOpts = defaultProgressBarOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        const concreteOpts = Object.assign({}, defaults, opts);
        const exists = yield fs_extra_1.default.pathExists(filePath);
        if (!exists)
            throw new Error(`file ${filePath} does not exist`);
        if (folder) {
            const folderExists = yield fs_extra_1.default.pathExists(filePath);
            if (!folderExists && !concreteOpts.ensureDir) {
                throw new Error(`folder ${folder} does not exist`);
            }
            if (!folderExists && concreteOpts.ensureDir) {
                fs_extra_1.default.ensureDir(folder);
            }
        }
        const finalFolder = folder || path_1.default.dirname(filePath);
        const stat = yield fs_extra_1.default.stat(filePath);
        let maxBytes = stat.size;
        let processedBytes = 0;
        const startedAt = Date.now();
        const concreteProgressBarOpts = Object.assign({}, defaultProgressBarOpts, progressBarOpts);
        const bar = new cli_progress_1.default.SingleBar(concreteProgressBarOpts);
        bar.start(maxBytes, 0, { speed: 'N/A' });
        const promise = tar_1.default.x({
            file: filePath,
            C: finalFolder,
            onentry: entry => {
                if (!entry.size) {
                    return;
                }
                processedBytes += entry.size;
                const elapsed = (Date.now() - startedAt) / 1000;
                const rate = processedBytes / elapsed;
                const rateh = `${(0, pretty_bytes_1.default)(rate)}/s`;
                const estimated = maxBytes / rate;
                // const progress = this.done / this.total
                const eta = estimated - elapsed;
                const etaDate = (0, date_fns_1.addSeconds)(new Date(), eta);
                const etah = (0, date_fns_1.formatDistanceToNow)(etaDate, { includeSeconds: true });
                bar.update(processedBytes, { speed: rateh, etah: etah });
            }
        });
        yield promise;
        bar.update(stat.size);
        return promise;
    });
}
exports.extract = extract;
//# sourceMappingURL=progress-bar-file-extractor.js.map