"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkOne = exports.linkDefault = exports.linkAll = void 0;
const bvm_config_1 = require("@teambit/bvm.config");
const bvm_list_1 = require("@teambit/bvm.list");
const path_1 = __importDefault(require("path"));
const bin_links_1 = __importDefault(require("bin-links"));
const bvm_error_1 = require("@teambit/bvm.error");
const os_1 = __importDefault(require("os"));
const chalk_1 = __importDefault(require("chalk"));
const IS_WINDOWS = os_1.default.platform() === 'win32';
const DOCS_BASE_URL = 'https://harmony-docs.bit.dev';
const WINDOWS_INSTALL_TROUBLESHOOTING_DOCS_URL = `${DOCS_BASE_URL}/introduction/installation`;
const MAC_LINUX_INSTALL_TROUBLESHOOTING_DOCS_URL = `${DOCS_BASE_URL}/introduction/installation`;
const config = bvm_config_1.Config.load();
function linkAll() {
    return __awaiter(this, void 0, void 0, function* () {
        const links = config.getLinks();
        const defaultLinkVersion = config.getDefaultLinkVersion();
        const localLatest = (yield (0, bvm_list_1.listLocal)()).latest();
        const promises = Object.entries(links).map(([linkName, version]) => {
            return linkOne(linkName, version, false);
        });
        if (!defaultLinkVersion && localLatest) {
            const defaultLinkName = config.getDefaultLinkName();
            promises.push(linkOne(defaultLinkName, localLatest.version, true));
        }
        return Promise.all(promises);
    });
}
exports.linkAll = linkAll;
function linkDefault(version, addToConfig = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultLinkName = config.getDefaultLinkName();
        return linkOne(defaultLinkName, version, addToConfig);
    });
}
exports.linkDefault = linkDefault;
function linkOne(linkName, version, addToConfig = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const source = getLinkSource();
        let concreteVersion = version;
        if (!concreteVersion || concreteVersion === 'latest') {
            const localLatest = (yield (0, bvm_list_1.listLocal)()).latest();
            concreteVersion = localLatest.version;
        }
        const { versionDir, exists } = config.getSpecificVersionDir(concreteVersion, true);
        if (!exists) {
            throw new bvm_error_1.BvmError(`version ${concreteVersion} is not installed`);
        }
        const pkg = {
            bin: {
                [linkName]: source
            }
        };
        const opts = {
            path: versionDir,
            pkg,
            global: true,
            top: true,
            force: true,
        };
        const rawGeneratedLinks = bin_links_1.default.getPaths(opts);
        const generatedLink = {
            source: versionDir,
            target: rawGeneratedLinks[0]
        };
        yield (0, bin_links_1.default)(opts);
        let previousLinkVersion;
        if (addToConfig) {
            previousLinkVersion = config.setLink(linkName, concreteVersion);
        }
        let binDir = path_1.default.join(os_1.default.homedir(), 'bin');
        if (IS_WINDOWS) {
            binDir = config.getBvmDirectory();
        }
        validateBinDirInPath(binDir);
        return {
            linkName,
            previousLinkVersion,
            version: concreteVersion,
            generatedLink
        };
    });
}
exports.linkOne = linkOne;
function getLinkSource() {
    const bitBinPath = getBitBinPath();
    const source = path_1.default.join('.', 'node_modules', bitBinPath);
    return source;
}
function getBitBinPath() {
    return path_1.default.join('@teambit', 'bit', 'bin', 'bit');
}
function validateBinDirInPath(binDir) {
    const osPaths = (process.env.PATH || process.env.Path || process.env.path).split(path_1.default.delimiter);
    if (osPaths.indexOf(binDir) === -1) {
        const err = IS_WINDOWS ? windowsMissingInPathError(binDir, WINDOWS_INSTALL_TROUBLESHOOTING_DOCS_URL) : macLinuxMissingInPathError(binDir, MAC_LINUX_INSTALL_TROUBLESHOOTING_DOCS_URL);
        console.log(chalk_1.default.yellowBright(err));
    }
}
function windowsMissingInPathError(binDir, docsLink) {
    // Join with \n for better visibility in windows
    const errLines = [
        'global Bit install location was not found in your PATH global variable.',
        'please run the following command and then re-open the terminal:',
        `setx path "%path%;${binDir}" and re-open your terminal`,
        `for more information read here - ${docsLink}
    `
    ];
    return errLines.join('\n');
}
function macLinuxMissingInPathError(binDir, docsLink) {
    // Join with \n for better visibility in windows
    const errLines = [
        'global Bit install location was not found in your PATH global variable.',
        'please add the following to your bash/zsh profile then re-open the terminal:',
        `export PATH=$HOME/bin:$PATH`,
        `for more information read here - ${docsLink}
    `
    ];
    return errLines.join('\n');
}
//# sourceMappingURL=link.js.map